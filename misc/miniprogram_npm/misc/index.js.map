{"version":3,"sources":["misc.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// misc - v1.0.1 - MIT License\n// 2015 (c) OrderGroove Developers\n\n(function() {\n    \n\n    /**\n     * Miscellaneous utility functions\n     * @class misc\n     * @static\n     */\n    var _ = {};\n\n    /* istanbul ignore next */\n    /**\n     * Polyfill for Array.prototype.slice\n     * @method slice\n     * @param {Array} arr\n     * @param {number} begin\n     * @param {number} end\n     */\n    _.slice = (function() {\n        var _slice = Array.prototype.slice;\n        var invalidSlice = false;\n\n        try {\n            // Can't be used with DOM elements in IE < 9\n            _slice.call(document.documentElement);\n        } catch (e) { // Fails in IE < 9\n            invalidSlice = true;\n        }\n\n        if (invalidSlice) {\n            return function(arr, begin, end) {\n                var i, arrl = arr.length, a = [];\n\n                if (arr === null) {\n                    throw new TypeError('Array.prototype.slice called on null or undefined');\n                }\n\n                begin = begin === null ? 0 : (begin >= 0 ? begin : arrl - begin);\n                end = end === null ? arrl : (end >= 0 ? end : arrl - end);\n                // Although IE < 9 does not fail when applying Array.prototype.slice\n                // to strings, here we do have to duck-type to avoid failing\n                // with IE < 9's lack of support for string indexes\n                if (arr.charAt) {\n                    for (i = begin; i < end; i++) {\n                        a.push(arr.charAt(i));\n                    }\n                // This will work for genuine arrays, array-like objects,\n                // NamedNodeMap (attributes, entities, notations),\n                // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),\n                // and will not fail on other DOM objects (as do DOM elements in IE < 9)\n                } else {\n                    // IE < 9 (at least IE < 9 mode in IE 10) does not work with\n                    // node.attributes (NamedNodeMap) without a dynamically checked length here\n                    for (i = begin; i < end; i++) {\n                        a.push(arr[i]);\n                    }\n                }\n                // IE < 9 gives errors here if end is allowed as undefined\n                // (as opposed to just missing) so we default ourselves\n                return a;\n            };\n        } else {\n            return function(arr, begin, end) {\n                return _slice.call(arr, begin, end);\n            };\n        }\n    })();\n\n    /* istanbul ignore next */\n    /***\n     * Get the keys for an object or function\n     * @method keys\n     * @param {object|function} obj\n     * @return {Array} array of key strings\n     */\n    _.keys = (function() {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n            dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ],\n            dontEnumsLength = dontEnums.length;\n        return function(objOrFunc) {\n            if (Object.prototype.keys) {\n                return Object.keys(objOrFunc);\n            }\n            if (typeof objOrFunc !== 'object' && (typeof objOrFunc !== 'function' || objOrFunc === null)) {\n                throw new TypeError('Object.keys called on non-object');\n            }\n\n            var result = [], prop, i;\n\n            for (prop in objOrFunc) {\n                if (hasOwnProperty.call(objOrFunc, prop)) {\n                    result.push(prop);\n                }\n            }\n\n            if (hasDontEnumBug) {\n                for (i = 0; i < dontEnumsLength; i++) {\n                    if (hasOwnProperty.call(objOrFunc, dontEnums[i])) {\n                        result.push(dontEnums[i]);\n                    }\n                }\n            }\n            return result;\n        };\n    })();\n\n    /***\n     * Get all the values in an object\n     * @method values\n     * @param {Object} obj\n     * @returns {Array}\n     */\n    _.values = function(obj) {\n        var vals = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                vals.push(obj[key]);\n            }\n        }\n        return vals;\n    };\n\n    /***\n     * Convert an array to an object map.\n     * @method toMap\n     * @param {Array} arr\n     * @param {string|function} keyOrFunc\n     * @returns {object}\n     */\n    _.toMap = function(arr, keyOrFunc) {\n        var map = {}, i, len, item, key;\n        for (i = 0, len = arr.length; i < len; i++) {\n            item = arr[i];\n            if (typeof keyOrFunc === 'string') {\n                key = item[keyOrFunc];\n\n                // Assuming its a function\n            } else {\n                key = keyOrFunc(item);\n            }\n            // Don't add keys that are null or undefined\n            if (key !== null && key !== undefined) {\n                map[key] = item;\n            }\n        }\n        return map;\n    };\n\n    /* istanbul ignore next */\n    /***\n     * Return a function with optional bound this and arguments\n     * @method bind\n     * @param {function} func\n     * @param {*} thisArg\n     * @returns {function}\n     */\n    _.bind = function(func, thisArg /*, arguments */) {\n        if (func.bind) {\n            return func.bind.apply(func, Array.prototype.slice.call(arguments, 1));\n        }\n\n        if (typeof func !== 'function') {\n            // closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n        }\n\n        var aArgs = Array.prototype.slice.call(arguments, 2),\n            fToBind = func,\n            FNOP = function() {\n            },\n            FBound = function() {\n                return fToBind.apply(this instanceof FNOP && thisArg ?\n                    func\n                    : thisArg,\n                    aArgs.concat(Array.prototype.slice.call(arguments)));\n            };\n\n        FNOP.prototype = func.prototype;\n        FBound.prototype = new FNOP();\n\n        return FBound;\n    };\n\n    /* istanbul ignore next */\n    /***\n     * Return string with first character capitalized\n     * @method capitalize\n     * @param {string} str\n     * @returns {string}\n     */\n    _.capitalize = function(str) {\n        return str.charAt(0).toUpperCase() + str.slice(1);\n    };\n\n    /* istanbul ignore next */\n    /***\n     * MDN Polyfill for Array.prototype.indexOf\n     * @method indexOf\n     * @param {Array} arr the array to search\n     * @param {*} searchElement\n     * @param {number} fromIndex\n     * @returns {number} index of the searchElement, -1 if not found\n     */\n    _.indexOf = function(arr, searchElement, fromIndex) {\n        if (arr.indexOf) {\n            return arr.indexOf(searchElement, fromIndex);\n        }\n\n        if (arr === null) {\n            throw new TypeError('\"arr\" is null or not defined');\n        }\n\n        /*jshint bitwise: false */\n        var length = this.length >>> 0; // Hack to convert object.length to a UInt32\n\n        fromIndex = +fromIndex || 0;\n\n        if (Math.abs(fromIndex) === Infinity) {\n            fromIndex = 0;\n        }\n\n        if (fromIndex < 0) {\n            fromIndex += length;\n            if (fromIndex < 0) {\n                fromIndex = 0;\n            }\n        }\n\n        for (; fromIndex < length; fromIndex++) {\n            if (arr[fromIndex] === searchElement) {\n                return fromIndex;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Determine if searchElement is in array or string\n     * @param {string|Array} arr\n     * @param {*} searchElement\n     * @param {number} fromIndex\n     * @returns {boolean}\n     */\n    _.contains = function(arr, searchElement, fromIndex) {\n        return _.indexOf(arr, searchElement, fromIndex) !== -1;\n    };\n\n    /***\n     * Attach all the properties of other object onto the first object\n     * @method extend\n     * @param {object} obj\n     * @returns {object}\n     */\n    _.extend = function(obj /*, objects...*/) {\n        var i, len, source;\n        for (i = 1, len = arguments.length; i < len; i++) {\n            source = arguments[i];\n            if (source) {\n                for (var prop in source) {\n                    obj[prop] = source[prop];\n                }\n            }\n        }\n        return obj;\n    };\n\n    /***\n     * Attach all the properties of an object onto first object, recurse if property is object\n     * @method deepExtend\n     * @param {object} obj\n     * @returns {object}\n     */\n    _.deepExtend = function(obj /*, objects...*/) {\n        var i, len, source;\n        for (i = 1, len = arguments.length; i < len; i++) {\n            source = arguments[i];\n            if (source) {\n                for (var prop in source) {\n                    if (_.isObject(source[prop])) {\n                        if (!obj.hasOwnProperty(prop)) {\n                            obj[prop] = {};\n                        }\n                        obj[prop] = _.deepExtend(obj[prop], source[prop]);\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        return obj;\n    };\n\n    /***\n     * Function that does prototypical inheritance\n     * @method inherit\n     * @param {function} Parent Parent constructor function\n     * @param {function} Child Child constructor function\n     */\n    _.inherit = function(Child, Parent) {\n        function Temp() {\n            this.constructor = Child;\n        }\n\n        Temp.prototype = Parent.prototype;\n        Child.prototype = new Temp();\n    };\n\n    /***\n     * Get rid of extra whitespace at beginning or end of string\n     * @method trim\n     * @param {string} str\n     * @returns {string}\n     */\n    _.trim = function(str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n    };\n\n    /* istanbul ignore next */\n    /***\n     * MDN Polyfill for Array.prototype.map\n     * @method map\n     * @param {Array} arr\n     * @param {function} iterator\n     * @param {*} [thisArg]\n     * @returns {Array}\n     */\n    _.map = function(arr, iterator, thisArg) {\n        if (Array.prototype.map && arr.map === Array.prototype.map) {\n            return arr.map(iterator, thisArg);\n        }\n\n        if (arr === void 0 || arr === null) {\n            throw new TypeError();\n        }\n\n        var t = Object(arr);\n        /*jshint bitwise: false */\n        var len = t.length >>> 0;\n        if (typeof iterator !== 'function') {\n            throw new TypeError();\n        }\n\n        var res = new Array(len);\n        for (var i = 0; i < len; i++) {\n            if (i in t) {\n                res[i] = iterator.call(thisArg, t[i], i, t);\n            }\n        }\n        return res;\n    };\n\n    /**\n     * Return a new object with only the specified keys\n     * @method pick\n     * @param {object} obj\n     * @param {Array} keyArr Array of keys to pick from object\n     * @param {boolean} proxy Keep the `this` pointing to original object\n     */\n    _.pick = function(obj, keyArr, proxy) {\n        var newObj = {};\n        for (var i = 0, len = keyArr.length; i < len; i++) {\n            if (proxy && typeof obj[keyArr[i]] === 'function') {\n                newObj[keyArr[i]] = _.bind(obj[keyArr[i]], obj);\n            } else {\n                newObj[keyArr[i]] = obj[keyArr[i]];\n            }\n        }\n        return newObj;\n    };\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not be triggered.\n     * The function will be called after it stops being called for N milliseconds\n     * @method debounce\n     * @param {function} func\n     * @param {number} wait Milliseconds to wait\n     * @returns {Function}\n     */\n    _.debounce = function(func, wait) {\n        var timeout, args, me;\n        return function() {\n            me = this;\n            args = arguments;\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(function() {\n                func.apply(me, args);\n                timeout = null;\n            }, wait);\n        };\n    };\n\n    /**\n     * Check if a value is an array\n     * @method isArray\n     * @param {*} possibleArr\n     * @returns {boolean}\n     */\n    _.isArray = function(possibleArr) {\n        return Object.prototype.toString.call(possibleArr) === '[object Array]';\n    };\n\n    /**\n     * Check if a value is a plain object, not an array or String object, etc.\n     * @method isObject\n     * @param {*} possibleObj\n     * @returns {boolean}\n     */\n    _.isObject = function(possibleObj) {\n        return Object.prototype.toString.call(possibleObj) === '[object Object]';\n    };\n\n    /**\n     * Check testObj is in mainObj (partial object matching)\n     * @method containsObj\n     * @param {object} mainObj\n     * @param {object} testObj\n     * @returns {boolean}\n     */\n    _.containsObj = function(mainObj, testObj) {\n        if (mainObj === testObj) {\n            return true;\n        }\n        if (typeof mainObj !== typeof testObj) {\n            return false;\n        }\n        if (typeof mainObj === 'function' && typeof testObj === 'function') {\n            return true;\n        }\n        if (mainObj && typeof testObj === 'object') {\n            var key;\n            for (key in testObj) {\n                if (!_.containsObj(mainObj[key], testObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * returns a random number between a given min and max\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    _.random = function(min, max) {\n        if (typeof max === 'undefined') {\n            max = min;\n            min = 0;\n        }\n\n        if (min === max) {\n            return min;\n        }\n\n        return min + Math.floor(Math.random() * (max - min + 1));\n    };\n\n    /**\n     * Receives an array and returns a copy of it sorted randomly\n     * implementing Fisher-Yates algorithm (https://en.wikipedia.org/wiki/Fisher–Yates_shuffle)\n     * @method shuffle\n     * @param {array} arr\n     * @returns {array}\n     */\n    _.shuffle = function(arr) {\n        // return null if argument isn't an array\n        if (!_.isArray(arr)) {\n            return null;\n        }\n\n        if (arr.length > 1) {\n            var len = arr.length,\n                shuffled = new Array(len),\n                rand;\n\n            for (var i = 0; i < len; i++) {\n                rand = _.random(0, i);\n                if (rand !== i) {\n                    shuffled[i] = shuffled[rand];\n                }\n                shuffled[rand] = arr[i];\n            }\n            return shuffled;\n        } else {\n            // if single element array return copy of it\n            return arr.slice();\n        }\n    };\n\n    /**\n     * Wrap a function in a try, catch\n     * @method safeFn\n     * @param {Function} fn Function to try\n     * @param {Function} errorFn Function to call on exception\n     * @returns {Function}\n     */\n    _.safeFn = function(fn, onError) {\n        return function() {\n            try {\n                return fn.apply(this, arguments);\n            } catch (e) {\n                // Call the onError, but still catch errors\n                if (onError) {\n                    try {\n                        return onError(e);\n                    } catch (error) {}\n                }\n                return e;\n            }\n        };\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define([], _);\n    } else if (typeof exports === 'object') {\n        module.exports = _;\n    } else {\n        window._ = _;\n    }\n})();\n"]}